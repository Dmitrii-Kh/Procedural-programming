using namespace std;
#include <iostream>

double calcLog(double x, double accuracy) {
	double ln2 = 0.693147180;
	int k = 0;
	while (x > 2.0) {
		x /= 2.0;
		k++;
	}
	x -= 1;
	int i = 1;
	double log = 0, element = x;
	while (fabs(element) > accuracy) {
		log += element;
		i++;
		element *= -x * (i - 1) / i;
	}
	log += k * ln2;
	return log;
}
// Область визначення функції : D(f) = (0; +oo)


/* Спосіб розширення області визначення: якщо х, що подається на вхід, більше 2,
пропоную ділити х навпіл, поки х не стане <= 2. До того ж, ми зберігаємо в пам'яті 
скільки разів ми виконали це ділення (в змінній k). Роблю це в першому циклі while. 
Після обрахування значення логарифма для оновленого Х (другий цикл while), 
ми додаємо до цього значення добуток k*ln2. 
Приклад : ln(16) = ln(2) + 3*ln(2). 
Таким чином можемо розширити область визначення функції з (0;2], до (0; +оо). 
Запропонований алгоритм реалізовано. */



/* У цій функції я використав рекурентне співвідношення для ряду ln(X+1), 
але оскільки мене цікавить lnX, я декрементую Х що подається
на вхід (11 рядок). Таким чином, моя функція обраховує саме lnX. 
Слід зауважити, що декрементуючи Х, я не вихожу за межі збіжності ряду Тейлора
для lnX = (0:2], 
адже використовую рекурентне співвідношення для ln(X+1).
*Область збіжності ряду Тейлора для ln(X+1) = (-1;1). */



